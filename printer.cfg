## Anycubic Kobra Max ##
## Compile for HC32F460 ##
## Serial PA3 & PA2 "Anycube"

[include mainsail.cfg]

## Disable stealthchop and increase microsteps as per invisiblek
##       https://github.com/invisiblek/klipper_config/tree/kobraplus
## Adding this to try since I am experiencing severe Y layer shift

[stepper_x]
step_pin: PA5
dir_pin: PA4
enable_pin: !PC3
microsteps: 64
rotation_distance: 40
endstop_pin: !PA6
position_min: -6
position_endstop: -5
position_max: 407
homing_speed: 100

[tmc2209 stepper_x]
uart_pin:PA15
tx_pin:PA9
#diag_pin:PA6
sense_resistor: 0.100
run_current: 0.9
uart_address: 3
#driver_SGTHRS: 0
interpolate: False
stealthchop_threshold: 999999

[stepper_y]
step_pin: PC4
dir_pin: PA7
enable_pin: !PC3
microsteps: 64
rotation_distance: 40
endstop_pin: !PC5
position_min: -23.3
position_endstop: -23.2
position_max: 400
homing_speed: 100

[tmc2209 stepper_y]
uart_pin:PA15
tx_pin:PA9
#diag_pin:^PC5
sense_resistor: 0.100
run_current: 0.9
uart_address: 1
#driver_SGTHRS: 50
interpolate: False
stealthchop_threshold: 999999

# Don't forget to SET YOUR E-STEPS!
# Measure 120mm, then extrude 100mm
# G1 E100 F100
# step_distance = old_e_steps * ((120 - distance_to_mark) / 100)

[extruder]
max_extrude_only_distance: 100.0
step_pin: PC14
dir_pin: !PC15
enable_pin: !PC3
microsteps: 16
#rotation_distance: 7.71 #For stock extruder (To be calibrated !)
rotation_distance: 7.21
nozzle_diameter: 0.800
filament_diameter: 1.750
heater_pin: PA1
sensor_type: EPCOS 100K B57560G104F
sensor_pin: PC1
min_temp: 0
max_temp: 250

[tmc2208 extruder]
uart_pin:PA15
tx_pin:PA9
#diag_pin:PB7
sense_resistor: 0.100
run_current: 0.9
uart_address: 0
#stealthchop_threshold: 999999

[stepper_z]
step_pin: PC7
dir_pin: !PC6
enable_pin: !PC3
microsteps: 16
rotation_distance: 8
endstop_pin: probe:z_virtual_endstop
#endstop_pin: PA8
#position_endstop: 0
position_min: -20
position_max: 452
homing_speed: 5

[tmc2209 stepper_z]
uart_pin:PA15
tx_pin:PA9
#diag_pin:PA8
sense_resistor: 0.100
run_current: 0.9
uart_address: 2
#driver_SGTHRS: 0
stealthchop_threshold: 999999

[stepper_z1]
step_pin: PB1
dir_pin: !PB0
enable_pin: !PC3
microsteps: 16
rotation_distance: 8

[probe]
pin: !PB6
speed: 2.5
samples: 3
samples_tolerance_retries: 3
#z_offset: 0.05
activate_gcode: probe_reset

[gcode_macro probe_reset]
gcode:
    SET_PIN PIN=probe_reset_pin VALUE=1
    G4 P500
    SET_PIN PIN=probe_reset_pin VALUE=0
    G4 P100

[output_pin probe_reset_pin]
pin: !PB7

[safe_z_home]
home_xy_position: 203.5, 200 # Center of bed
speed: 100
z_hop: 5               # Move up 5mm
z_hop_speed: 20
move_to_previous: False

[bed_mesh]
speed: 100
horizontal_move_z: 3
mesh_min: 19, 19
mesh_max: 380, 380
algorithm: bicubic
probe_count: 5, 5

[output_pin LED]
pin: mcu:PB8
pwm: False
value: 0

[heater_bed]
heater_pin: PA0
sensor_type: EPCOS 100K B57560G104F
sensor_pin: PC0
#control = pid
#pid_kp = 73.966
#pid_ki = 0.884
#pid_kd = 1547.747
min_temp: 0
max_temp: 130

[fan]
pin: PB9

[heater_fan hotend_fan]
pin: PA13
heater: extruder
heater_temp: 50.0

[heater_fan controller_fan]
pin: PA14
heater: heater_bed
heater_temp: 45.0

[filament_switch_sensor runout]
pause_on_runout: True
switch_pin: !PC13

[mcu]
serial: /dev/serial/by-id/usb-1a86_USB_Serial-if00-port0
restart_method: command
baud: 250000

[temperature_sensor pi_temp]
sensor_type: temperature_host
min_temp: 0
max_temp: 100

[printer]
kinematics: cartesian
max_velocity: 150
max_accel: 4000
max_z_velocity: 5
max_z_accel: 100

#     In CURA use the following machine Start GCODE:
#
#     START_PRINT EXTRUDER_TEMP={material_print_temperature_layer_0} BED_TEMP={material_bed_temperature_layer_0} AREA_START=%MINX%,%MINY% AREA_END=%MAXX%,%MAXY%
#
#     If you want to edit your Start Print GCODE, do it in this configuration instead.

[gcode_macro START_PRINT]
gcode:
    G28; Home
    G1 X1 Y1 Z1; go to center while heating up
    G1 Z0.1 F600; lower Z to bed so blob will stick to it
    {% set BED_TEMP = params.BED_TEMP|default(60)|float %}
    {% set EXTRUDER_TEMP = params.EXTRUDER_TEMP|default(190)|float %}
    # Start bed heating (but don't wait for it)
    M140 S{BED_TEMP}
    #Start extruder heating (but don't wait for it)
    M109 S{EXTRUDER_TEMP}
    # Use absolute coordinates
    G90
    # Wait for bed to reach temperature
    M190 S{BED_TEMP}
    # Set and wait for nozzle to reach temperature
    M109 S{EXTRUDER_TEMP}
    BED_MESH_CLEAR
    BED_MESH_PROFILE REMOVE="default"
    G1 Z0.05
    G1 Z1
    G1 X10 Y10; remove the blob
    G28 Z; recalibrate Z now that we are at temp
    BED_MESH_CALIBRATE AREA_START={params.AREA_START|default("0,0")} AREA_END={params.AREA_END|default("0,0")}
    BED_MESH_PROFILE LOAD="default"
    SET_PIN PIN=LED VALUE=1.00

#     In CURA use the following machine End GCODE:
#
#     END_PRINT
#
#     If you want to edit your End Print GCODE, do it in this configuration instead.

[gcode_macro END_PRINT]
gcode:
    G91
    M106 S0
    M104 S0
    M140 S0
    G1 E-2 F2700
    G1 E-2 Z0.2 F2400
    G1 X5 Y5 F3000
    G1 Z10
    G90
    G1 X10 Y400; raise z 10mm
    M84 X Y Z E; turn off all the steppers
    #turn off the light
    SET_PIN PIN=LED VALUE=0.00

[gcode_macro DO_A_MESH]
gcode:
    #unload the existing mesh profile
    BED_MESH_CLEAR
    M140 S60; PREHEAT bed
    M109 S175; PREHEAT nozzle
    #clear the existing mesh out 
    BED_MESH_PROFILE REMOVE="default"
    # Wait for bed to reach temperature
    M190 S60
    # Set and wait for nozzle to reach temperature
    M109 S215
    G28; home axes
    #perform a standard full-bed mesh level
    BED_MESH_CALIBRATE_BASE


# This macro is to mesh only the area of the bed which will be printed on
# In order to take advantage of this option, there is further work you will need to do in your slicer software
# If you do not use Cura, please visit the following link to finish setting this up:
#
#                 https://gist.github.com/ChipCE/95fdbd3c2f3a064397f9610f915f7d02
#
# If you DO use Cura, I have already taken most steps for you. Please visit the following link to download the post processing plugin. Save this text as KlipperPrintArea.py.
#
#                 https://raw.githubusercontent.com/ChipCE/Slicer-profile/master/cura-slicer/scripts/KlipperPrintArea.py
#
# In cura menu Help -> Show configuration folder. - Copy the python script from the above link in to scripts folder. - Restart Cura - In cura menu Extensions -> Post processing -> Modify G-Code and select Klipper print area mesh


[gcode_macro BED_MESH_CALIBRATE]
rename_existing: BED_MESH_CALIBRATE_BASE
; gcode parameters
variable_parameter_AREA_START : 0,0
variable_parameter_AREA_END : 0,0
; the clearance between print area and probe area 
variable_mesh_area_offset : 5.0
; number of sample per probe point
variable_probe_samples : 2
; minimum probe count
variable_min_probe_count : 4
; scale up the probe count, should be 1.0 ~ < variable_max_probe_count/variable_min_probe_count
variable_probe_count_scale_factor : 1.0
; enable preference index
variable_enable_reference_index : False
gcode:
    {% if params.AREA_START and params.AREA_END %}
        {% set bedMeshConfig = printer["configfile"].config["bed_mesh"] %}
        {% set safe_min_x = bedMeshConfig.mesh_min.split(",")[0]|float %}
        {% set safe_min_y = bedMeshConfig.mesh_min.split(",")[1]|float %}
        {% set safe_max_x = bedMeshConfig.mesh_max.split(",")[0]|float %}
        {% set safe_max_y = bedMeshConfig.mesh_max.split(",")[1]|float %}

        {% set area_min_x = params.AREA_START.split(",")[0]|float %}
	{% set area_min_y = params.AREA_START.split(",")[1]|float %}
	{% set area_max_x = params.AREA_END.split(",")[0]|float %}
	{% set area_max_y = params.AREA_END.split(",")[1]|float %}

	{% if bedMeshConfig.probe_count.split(",")|length == 2 %}
            {% set meshPointX = bedMeshConfig.probe_count.split(",")[0]|int %}
            {% set meshPointY = bedMeshConfig.probe_count.split(",")[1]|int %}
        {% else %}
            {% set meshPointX = bedMeshConfig.probe_count.split(",")[0]|int %}
            {% set meshPointY = bedMeshConfig.probe_count.split(",")[0]|int %}
        {% endif %}

	{% set meshMaxPointX = meshPointX %}
	{% set meshMaxPointY = meshPointY %}


        {% if (area_min_x < area_max_x) and (area_min_y < area_max_y) %}
            {% if area_min_x - mesh_area_offset >=  safe_min_x %}
                {% set area_min_x = area_min_x - mesh_area_offset %}
            {% else %}
                {% set area_min_x = safe_min_x %}
            {% endif %}

            {% if area_min_y - mesh_area_offset >=  safe_min_y %}
                {% set area_min_y = area_min_y - mesh_area_offset %}
            {% else %}
                {% set area_min_y = safe_min_y %}
            {% endif %}

            {% if area_max_x + mesh_area_offset <=  safe_max_x %}
                {% set area_max_x = area_max_x + mesh_area_offset %}
            {% else %}
                {% set area_max_x = safe_max_x %}
            {% endif %}

            {% if area_max_y + mesh_area_offset <=  safe_max_y %}
                {% set area_max_y = area_max_y + mesh_area_offset %}
            {% else %}
                {% set area_max_y = safe_max_y %}
            {% endif %}

            {% set meshPointX = (meshPointX * (area_max_x - area_min_x) / (safe_max_x - safe_min_x) * probe_count_scale_factor)|round(0)|int %}
            {% if meshPointX < min_probe_count %}
                {% set meshPointX = min_probe_count %}
            {% endif %}
	    {% if meshPointX > meshMaxPointX %}
                {% set meshPointX = meshMaxPointX %}
            {% endif %}

            {% set meshPointY = (meshPointY * (area_max_y -area_min_y ) / (safe_max_y - safe_min_y) * probe_count_scale_factor )|round(0)|int %}
            {% if meshPointY < min_probe_count %}
                {% set meshPointY = min_probe_count %}
            {% endif %}
	    {% if meshPointY > meshMaxPointY %}
                {% set meshPointY = meshMaxPointY %}
            {% endif %}

            {% set algorithm = "bicubic" %}
	    {% if "algorithm" in bedMeshConfig %}
	        {% set algorithm = bedMeshConfig.algorithm %}
            {% endif %}
            {% if meshPointX >=7 or meshPointY >=7 %}
                {% set algorithm = "bicubic" %}
            {% endif %}

            {% if enable_reference_index %}
                {% set referenceIndex = (meshPointX * meshPointY / 2 - 1 )|round(0)|int %}
                BED_MESH_CALIBRATE_BASE mesh_min={area_min_x},{area_min_y} mesh_max={area_max_x},{area_max_y} probe_count={meshPointX},{meshPointY} samples={probe_samples|int} algorithm={algorithm} relative_reference_index={referenceIndex}
            {% else %}
                BED_MESH_CALIBRATE_BASE mesh_min={area_min_x},{area_min_y} mesh_max={area_max_x},{area_max_y} probe_count={meshPointX},{meshPointY} samples={probe_samples|int} algorithm={algorithm}
            {% endif %}
        {% else %}
            BED_MESH_CALIBRATE_BASE
        {% endif %}
    {% else %}
        BED_MESH_CALIBRATE_BASE
    {% endif %}


# This is the SPEED TEST MACRO written by Andrew Ellis (ellis3dp.com).
# Please read the documentation before torturing your printer with it!
#
#     https://ellis3dp.com/Print-Tuning-Guide/articles/determining_max_speeds_accels.html
#
# Home, get position, throw around toolhead, home again.
# If MCU stepper positions (first line in GET_POSITION) are greater than a full step different (your number of microsteps), then skipping occured.
# We only measure to a full step to accomodate for endstop variance.
# Example: TEST_SPEED SPEED=300 ACCEL=5000 ITERATIONS=10

[gcode_macro TEST_SPEED]
gcode:
    # Speed
    {% set speed  = params.SPEED|default(printer.configfile.settings.printer.max_velocity)|int %}
    # Iterations
    {% set iterations = params.ITERATIONS|default(5)|int %}
    # Acceleration
    {% set accel  = params.ACCEL|default(printer.configfile.settings.printer.max_accel)|int %}
    # Bounding inset for large pattern (helps prevent slamming the toolhead into the sides after small skips, and helps to account for machines with imperfectly set dimensions)
    {% set bound = params.BOUND|default(20)|int %}
    # Size for small pattern box
    {% set smallpatternsize = SMALLPATTERNSIZE|default(20)|int %}
    
    # Large pattern
        # Max positions, inset by BOUND
        {% set x_min = printer.toolhead.axis_minimum.x + bound %}
        {% set x_max = printer.toolhead.axis_maximum.x - bound %}
        {% set y_min = printer.toolhead.axis_minimum.y + bound %}
        {% set y_max = printer.toolhead.axis_maximum.y - bound %}
    
    # Small pattern at center
        # Find X/Y center point
        {% set x_center = (printer.toolhead.axis_minimum.x|float + printer.toolhead.axis_maximum.x|float ) / 2 %}
        {% set y_center = (printer.toolhead.axis_minimum.y|float + printer.toolhead.axis_maximum.y|float ) / 2 %}
        
        # Set small pattern box around center point
        {% set x_center_min = x_center - (smallpatternsize/2) %}
        {% set x_center_max = x_center + (smallpatternsize/2) %}
        {% set y_center_min = y_center - (smallpatternsize/2) %}
        {% set y_center_max = y_center + (smallpatternsize/2) %}

    # Save current gcode state (absolute/relative, etc)
    SAVE_GCODE_STATE NAME=TEST_SPEED
    
    # Output parameters to g-code terminal
    { action_respond_info("TEST_SPEED: starting %d iterations at speed %d, accel %d" % (iterations, speed, accel)) }
    
    # Home and get position for comparison later:
        G28
        # QGL if not already QGLd (only if QGL section exists in config)
        {% if printer.configfile.settings.quad_gantry_level %}
            {% if printer.quad_gantry_level.applied == False %}
                QUAD_GANTRY_LEVEL
                G28 Z
            {% endif %}
        {% endif %} 
        # Move 50mm away from max position and home again (to help with hall effect endstop accuracy - https://github.com/AndrewEllis93/Print-Tuning-Guide/issues/24)
        G90
        G1 X{printer.toolhead.axis_maximum.x-50} Y{printer.toolhead.axis_maximum.y-50} F{30*60}
        G28 X Y
        G0 X{printer.toolhead.axis_maximum.x-1} Y{printer.toolhead.axis_maximum.y-1} F{30*60}
        G4 P1000 
        GET_POSITION

    # Go to starting position
    G0 X{x_min} Y{y_min} Z{bound + 10} F{speed*60}

    # Set new limits
    SET_VELOCITY_LIMIT VELOCITY={speed} ACCEL={accel} ACCEL_TO_DECEL={accel / 2}

    {% for i in range(iterations) %}
        # Large pattern
            # Diagonals
            G0 X{x_min} Y{y_min} F{speed*60}
            G0 X{x_max} Y{y_max} F{speed*60}
            G0 X{x_min} Y{y_min} F{speed*60}
            G0 X{x_max} Y{y_min} F{speed*60}
            G0 X{x_min} Y{y_max} F{speed*60}
            G0 X{x_max} Y{y_min} F{speed*60}
            
            # Box
            G0 X{x_min} Y{y_min} F{speed*60}
            G0 X{x_min} Y{y_max} F{speed*60}
            G0 X{x_max} Y{y_max} F{speed*60}
            G0 X{x_max} Y{y_min} F{speed*60}
        
        # Small pattern
            # Small diagonals 
            G0 X{x_center_min} Y{y_center_min} F{speed*60}
            G0 X{x_center_max} Y{y_center_max} F{speed*60}
            G0 X{x_center_min} Y{y_center_min} F{speed*60}
            G0 X{x_center_max} Y{y_center_min} F{speed*60}
            G0 X{x_center_min} Y{y_center_max} F{speed*60}
            G0 X{x_center_max} Y{y_center_min} F{speed*60}
            
            # Small box
            G0 X{x_center_min} Y{y_center_min} F{speed*60}
            G0 X{x_center_min} Y{y_center_max} F{speed*60}
            G0 X{x_center_max} Y{y_center_max} F{speed*60}
            G0 X{x_center_max} Y{y_center_min} F{speed*60}
    {% endfor %}

    # Restore max speed/accel/accel_to_decel to their configured values
    SET_VELOCITY_LIMIT VELOCITY={printer.configfile.settings.printer.max_velocity} ACCEL={printer.configfile.settings.printer.max_accel} ACCEL_TO_DECEL={printer.configfile.settings.printer.max_accel_to_decel} 

    # Re-home and get position again for comparison:
        G28
        # Go to XY home positions (in case your homing override leaves it elsewhere)
        G90
        G0 X{printer.toolhead.axis_maximum.x-1} Y{printer.toolhead.axis_maximum.y-1} F{30*60}
        G4 P1000 
        GET_POSITION

    # Restore previous gcode state (absolute/relative, etc)
    RESTORE_GCODE_STATE NAME=TEST_SPEED

#*# <---------------------- SAVE_CONFIG ---------------------->
#*# DO NOT EDIT THIS BLOCK OR BELOW. The contents are auto-generated.
#*#
#*# [heater_bed]
#*# control = pid
#*# pid_kp = 69.538
#*# pid_ki = 0.893
#*# pid_kd = 1353.388
#*#
#*# [extruder]
#*# control = pid
#*# pid_kp = 28.130
#*# pid_ki = 1.875
#*# pid_kd = 105.487
#*#
#*# [probe]
#*# z_offset = -0.120
